clc;clear;


format long

% %% ****************************************初始化参数************************************************************************************************************************************************************
for nummmmmm = 1
    fc = 30e9;   %载波频率
    c = 3e8;      %光速
    lambda = c/fc;   %波长；
    dx = lambda/4;   %x轴方向天线间隔
    dy = lambda/4;  %y轴方向天线间隔
    Mx = 32; My = 32; M = Mx * My;
    Q  = 1; %每个全息超表面馈源个数
    Dx = Mx * dx;   Dy = My * dy;
    K_rice = 1;
    K = 6; %用户个数
    B = 6; %全息超表面个数，每个全息超表面上配备有M个元素
    NUM_Position = 100; %6DMA空间位置
    delta_x = ( 2 * [0:(Mx-1)].' - Mx + 1 )/2; delta_y = ( 2 * [ 0 : ( My - 1 ) ].' - My + 1 )/2;
    % delta_x = [0:(Mx-1)].';   delta_y = [0:(My-1)].';
    % Coor_Ele_init = [ kron( ones(My,1) , delta_x*dx ) , kron( delta_y*dy , ones(Mx,1) ) , zeros(M,1)  ];  %辐射元素坐标
    Coor_Ele_init = [ kron( delta_x*dx , ones(My,1) ) , kron( ones(Mx,1) , delta_y*dy ) , zeros(M,1)  ];  %辐射元素坐标
    dmin = 0.1;
% figure(1); plot( Coor_Ele_init(:,1) , Coor_Ele_init(:,2) , 'o' )
% % 
%% 引入全息超表面传输模型
Coor_Feed    = [ 0.002984305671304 , 0.001586131606604 , 0 ];   %馈源坐标
% Coor_Feed    = [ 0 , 3.838239570983593e-04 , 0 ];
Dis_Feed2Ele = sqrt( ( Coor_Ele_init - Coor_Feed ).^2 * ones(3,1) );    %馈源到元素的距离
V_F          = exp( - 1j * 2*pi*sqrt(3)/lambda * Dis_Feed2Ele );    %馈源响应向量
end

% % 计算全息超表面波束增益
% bs = @(theta,phi) exp( 1j * 2*pi/lambda * ( kron( [0:Mx-1].' , ones(My,1) ) * dx * theta + kron( ones(Mx,1) , [0:My-1].' ) * dy * phi ) );
% num=1;num1 = 1;
% parfor num1 = 1:201
%    
%     for num2 = 1:201
%         m = (real( V_F .* bs( (num1-101)/100 , (num2-101)/100 ))+1)/2;
%         BeamGain(num1,num2) = abs(bs((num1-101)/100 , (num2-101)/100).' * diag(m) * V_F);
%     end
% end
% 
% % 生成数据
% [X, Y] = meshgrid(-1:0.01:1, -1:0.01:1);
% Z = BeamGain;
% 
% % 绘制表面图
% figure;
% mesh(X, Y, Z, 'EdgeColor', 'interp', 'FaceColor', 'interp');
% title('Heatmap Using surf');
% 
% % 添加颜色条
% colorbar;
% % 设置颜色映射
% 
% colormap(jet);
% 
% % 调整视角为从上方观看
% view(2);
% 
% % 设置坐标轴比例
% axis tight;

% Mx=32,My=32,最大增益方向为(0.02,0.01);


for  num = 1 : 1
%% 6DMA初始空间姿态
% Coor_Ele表示6DMA天线坐标，normal_vector是UPA的法向量
[ Coor_Ele , normal_vector , Rot_Matrix ] = Orientation_Initial(B,Coor_Ele_init,0);
%% 针对初始6DMA位置，生成无线信道
[ h , e0 ] = Channel_Generation_init( K,B,M,Mx,My,normal_vector,K_rice,Coor_Ele,lambda , Rot_Matrix );
%% 生成全息感知
[ error_theta , error_phi , error_varphi , est_direc_vector_rec , Rot_Matrix , normal_vector_rot ] = Sensing_Holographic_HalfWave1(B,M,Mx,My,lambda,delta_x,delta_y,dx,dy,K,h,Rot_Matrix,e0);
% est_direc_vector_rec：指向用户的方向向量
% normal_vector_rot：全息超表面的法向量
% Rot_Matrix：旋转矩阵
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Check %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % 全局坐标
% Coor_g = Rot_Matrix{2} * Coor_Ele_init.'
% % % 局部坐标
% Coor_l = Rot_Matrix{2}.' * Coor_g;



%% 对误差数据进行高斯拟合
for nummmmmmmmmmmm = 1

% mu_theta          = mean( error_theta );
% sigma_theta       = std( error_theta );
% theta_values      = linspace( min( error_theta ) , max( error_theta ) , 10000 );
% pdf_theta_values  = normpdf( theta_values , mu_theta , sigma_theta );
% figure(2); hold on;
% histogram( error_theta , 20 , 'Normalization' , 'pdf' );
% plot( theta_values , pdf_theta_values , 'r' , 'LineWidth' , 2 )
% hold off;
% grid on;
% title( 'Comparison of two distributions' );
% xlabel( 'Error of $\theta$','Interpreter','latex' );
% ylabel( 'Probability' );
% legend( 'Simulation' , 'Fitting' )
% 
% mu_phi          = mean( error_phi );
% sigma_phi       = std( error_phi );
% phi_values      = linspace( min( error_phi ) , max( error_phi ) , 10000 );
% pdf_phi_values  = normpdf( phi_values , mu_phi , sigma_phi );
% figure(3); hold on;
% histogram( error_phi , 20,'Normalization' , 'pdf' );
% plot( phi_values , pdf_phi_values , 'r' , 'LineWidth' , 2 )
% hold off;
% grid on;
% title( 'Comparison of two distributions' );
% xlabel( 'Error of $\phi$','Interpreter','latex' );
% ylabel( 'Probability' );
% legend( 'Simulation' , 'Fitting' )
% 
% mu_theta_h          = mean( error_theta_h );
% sigma_theta_h       = std( error_theta_h );
% theta_h_values      = linspace( min( error_theta_h ) , max( error_theta_h ) , 10000 );
% pdf_theta_h_values  = normpdf( theta_h_values , mu_theta_h , sigma_theta_h/1.3 );
% figure(4); hold on;
% histogram( error_theta_h , 70 , 'Normalization' , 'pdf' );
% plot( theta_h_values , pdf_theta_h_values , 'r' , 'LineWidth' , 2 );
% hold off;
% grid on;
% title( 'Comparison of two distributions' );
% xlabel( 'Error of $\theta$','Interpreter','latex' );
% ylabel( 'Probability' );
% legend( 'Simulation' , 'Fitting' );

% mu_phi_h          = mean( error_phi_h );
% sigma_phi_h       = std( error_phi_h );
% phi_h_values      = linspace( min( error_phi_h ) , max( error_phi_h ) , 10000 );
% pdf_phi_h_values  = normpdf( phi_h_values , mu_phi_h , sigma_phi_h/1.5 );
% figure(5); hold on;
% histogram( error_phi_h , 70,'Normalization' , 'pdf' );
% plot( phi_h_values , pdf_phi_h_values , 'r' , 'LineWidth' , 2 );
% hold off;
% grid on;
% title( 'Comparison of two distributions' );
% xlabel( 'Error of $\phi$','Interpreter','latex' );
% ylabel( 'Probability' );
% legend( 'Simulation' , 'Fitting' );

end

%% 生成B个离散空间点的波束增益向量
B1 = 20; %一共有64个空间离散点位
% e = [ error_theta , error_phi , error_varphi ].'; % 估计方向向量：e \in e*K
for k = 1:B, e(:,k) = est_direc_vector_rec{k}; end
[ X , Y , Z ] = Orientation_uniformSpherePoints( B1 );
q = [ X.' , Y.' , Z.' ];
n1 = [ 0 ; 0 ; 1 ];

for k = 1:K
    %注意，dx = ( 2 * [0:(Mx-1)].' - Mx + 1 )/2
    Px{k}    = dx * Rot_Matrix{k} * [1;0;0];
    Py{k}    = dy * Rot_Matrix{k} * [0;1;0];
end





% 生成方向矩阵和距离矩阵
U_direc = zeros( B1 , K );   D_dis = zeros( B1 , B1 );
% for i = 1:B1
%     for j = 1:K
%         U_direc( i , j ) = ( Rot_Matrix{j} * [0;0;1] ).' * q(i,:).'   ;
%     end
% end
for i = 1:B1
    for j = 1:K
        U_direc( i , j ) = ( Rot_Matrix{j} * [0;0;1] ).' * q(i,:).'   ; %此处根据导向矢量求
    end
end
for i = 1:B1
    for j = 1:B1
        D_dis(i,j) = norm( q(i,:) - q(j,:) , 2 ) ;
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 初始空间姿态
for b = 1:B
    s(:,b) = [ zeros(b-1,1) ; 1 ; zeros( B1 - (b-1) - 1 , 1 ) ];
end
g = eye(B,B);


%% Alternating Optimizing Method
% 制备b个平移向量的可行区间,搜索初始可行解
tic
s_dic = zeros(B1,B1,B,B);  
for i1 = 1:B
    for i2 = 1:B
        if i1 == i2, s_dic(:,1,i1,i2) = ones(B1,1); else, s_dic(:,:,i1,i2) = ones(B1,B1); end
    end
end

for i1 = 1:B
    for i2 = 1:B
        for j1 = 1:B1
                s_temp1 = zeros(B1,1); s_temp1(j1) = 1;
                if s_temp1.' * U_direc * g(:,i1) <= 0, s_dic(j1,1,i1,i1) = 0 ; end
            for j2 = 1:B1
                s_temp2 = zeros(B1,1); s_temp2(j2) = 1;
                if s_temp1.' * D_dis * s_temp2 < dmin & i1 ~= i2, s_dic(j1,j2,i1,i2) = 0; end
                if (s_temp2 - s_temp1).' * U_direc * g(:,i1) >= 0 & i1 ~= i2, s_dic(j1,j2,i1,i2) = 0; end
            end
        end
    end
end

LoopUntil = 0;

Bset = 1:B1;

for m1 = Bset
    for m2 = Bset(Bset~=m1)
        for m3 = Bset(Bset~=m1&Bset~=m2)
            for m4 = Bset(Bset~=m1 & Bset~=m2 & Bset ~=m3)
                for m5 = Bset(Bset~=m1 & Bset~=m2 & Bset ~=m3 & Bset~=m4 )
                    for m6 = Bset(Bset~=m1 & Bset~=m2 & Bset ~=m3 & Bset~=m4 & Bset~=m5 )
                        if s_dic(m1,1,1,1) + s_dic(m2,1,2,2) + s_dic(m3,1,3,3) + s_dic(m4,1,4,4) + s_dic(m5,1,5,5) + s_dic(m6,1,6,6) + ...
                           s_dic(m1,m2,1,2) + s_dic(m1,m3,1,3) + s_dic(m1,m4,1,4) + s_dic(m1,m5,1,5) + s_dic(m1,m6,1,6) + ...
                           s_dic(m2,m1,2,1) + s_dic(m2,m3,2,3) + s_dic(m2,m4,2,4) + s_dic(m2,m5,2,5) + s_dic(m2,m6,2,6) + ...
                           s_dic(m3,m1,3,1) + s_dic(m3,m2,3,2) + s_dic(m3,m4,3,4) + s_dic(m3,m5,3,5) + s_dic(m3,m6,3,6) + ...
                           s_dic(m4,m1,4,1) + s_dic(m4,m2,4,2) + s_dic(m4,m3,4,3) + s_dic(m4,m5,4,5) + s_dic(m4,m6,4,6) + ...
                           s_dic(m5,m1,5,1) + s_dic(m5,m2,5,2) + s_dic(m5,m3,5,3) + s_dic(m5,m4,5,4) + s_dic(m5,m6,5,6) + ...
                           s_dic(m6,m1,6,1) + s_dic(m6,m2,6,2) + s_dic(m6,m3,6,3) + s_dic(m6,m4,6,4) + s_dic(m6,m5,6,5)  ...
                           == 36
                            LoopUntil = 1;
                            break;
                        end
                        if LoopUntil == 1, break; end
                    end
                    if LoopUntil == 1, break; end
                end
                if LoopUntil == 1, break; end
            end
            if LoopUntil == 1, break; end
        end
        if LoopUntil == 1, break; end
    end
    if LoopUntil == 1, break; end
end
s = zeros(B1,B);
if LoopUntil == 1
    s(m1,1) = 1;s(m2,2) = 1;s(m3,3) = 1;s(m4,4) = 1;s(m5,5) = 1;s(m6,6) = 1;
else 
    error('ERROR'); %必须存在可行点，才能进一步优化，否则不能进行优化
end
toc





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CHECK %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 改成新的模型
Xtr = ones(B,K);
coff   = diag( ones(K,1) ); %全息超表面波束系数
% 初始化波束增益，模拟波束
m_temp = zeros(M,B); %模拟波束增益


for k = 1:K
    for b = 1:B
        if normal_vector_rot{b}.' * est_direc_vector_rec{k} > 0
            a_st(:,k,b) =  exp( 1j * 2*pi/lambda * ( s(:,b).' * q * e(:,k) +  kron( delta_x * ( Px{b}.' * e(:,k) ) , ones(My,1) ) + kron( ones(Mx,1) , delta_y * ( Py{b}.' * e(:,k) ) )  ) ) ;
            
        else
            a_st(:,k,b)  = zeros(M,1);
        end
        m_temp(:,b)    = m_temp(:,b)  +  coff(k,b) * (  real( V_F .* a_st(:,k,b) + 1 ) / 2 )  ;
    end
end
mm = m_temp;
for k = 1:K
%     Gain_Beam(k,1) = 0 ;
    for k1 = 1:K
    for b = 1:B
%         Gain_Beam(k,1) = Gain_Beam(k,1) + abs( a_st{k,b}.' * diag( m_temp(:,b) ) *  V_F * Xtr(k) )^2 ;
        gain_beam_temp(k1,b,k) = a_st(:,k,b).' * diag( m_temp(:,b) ) *  V_F * Xtr(k1,b);
    end
    end
    Gain_Beam(k,1) = sum( abs( gain_beam_temp(:,:,k) * ones(B,1) ).^2 ); 
end
% %     for b = 1:B
% %         Gain_Beam(b,1) = abs( a_st{b,b}.' * diag( m_temp(:,b) ) *  V_F * Xtr(b) )^2 ; 
% %     end




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Optimization%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
psi = 0.1 * rand(K,K);
for ITE_NUM = 1:3


Gain_Beam_Fair = min( Gain_Beam ) ; %公平波束增益
Gain_Beam_Fair_ITE(1) = Gain_Beam_Fair;     Gain_Beam_Fair_old =Gain_Beam_Fair;
time1 = 0;    time2 = 0;                        
%没有在每次迭代完更新导向矢量

for ite_num = 1:3

for b1 = 1 : B1
    
    Gain_Beam_Fair_temp1 = zeros(B,1);

    for b = 1:B
tic
        m_temp = mm;
        s_temp = s;
        s_temp(:,b) = zeros(B1,1); s_temp(b1,b) = 1;
        
        for k0 = 1:K
            for b0 = 1:B
                if normal_vector_rot{b0}.' * est_direc_vector_rec{k0} > 0
                    a_st_temp(:,k0,b0) =  exp( 1j * 2*pi/lambda * ( (s_temp(:,b0).') * q * e(:,k0) +  kron( delta_x * ( Px{b0}.' * e(:,k0) ) , ones(My,1) ) + kron( ones(Mx,1) , delta_y * ( Py{b0}.' * e(:,k0) ) )  ) ) ;            
                else
                    a_st_temp(:,k0,b0)  = zeros(M,1);
                end
            end
            m_temp(:,b)    = m_temp(:,b)  +  coff(k0,b) * (  real( V_F .* a_st_temp(:,k0,b) + 1 ) / 2 )  ;
        end

        for k0 = 1:K
            %     Gain_Beam(k,1) = 0 ;
%             for k1 = 1:K
%                 for b0 = 1:B
%                     gain_beam_temp(k1,b0,k0) = a_st(:,k0,b0).' * diag( m_temp(:,b0) ) *  V_F * Xtr(k1,b0);
%                 end
%                 gain_beam_temp(k1,:,k0) = [ a_st(:,k0,1).' * diag( m_temp(:,1) ) *  V_F * Xtr(k1,1) ; a_st(:,k0,2).' * diag( m_temp(:,2) ) *  V_F * Xtr(k1,2) ; a_st(:,k0,3).' * diag( m_temp(:,3) ) *  V_F * Xtr(k1,3) ; a_st(:,k0,4).' * diag( m_temp(:,4) ) *  V_F * Xtr(k1,4) ; a_st(:,k0,5).' * diag( m_temp(:,5) ) *  V_F * Xtr(k1,5) ; a_st(:,k0,6).' * diag( m_temp(:,6) ) *  V_F * Xtr(k1,6) ];
%             end
            gain_beam_temp(:,:,k0) = [  a_st_temp(:,k0,1).' * diag( m_temp(:,1) ) *  V_F * Xtr(1,1) , a_st_temp(:,k0,1).' * diag( m_temp(:,1) ) *  V_F * Xtr(2,1) , a_st_temp(:,k0,1).' * diag( m_temp(:,1) ) *  V_F * Xtr(3,1) , a_st_temp(:,k0,1).' * diag( m_temp(:,1) ) *  V_F * Xtr(4,1) , a_st_temp(:,k0,1).' * diag( m_temp(:,1) ) *  V_F * Xtr(5,1) , a_st_temp(:,k0,1).' * diag( m_temp(:,1) ) *  V_F * Xtr(6,1) 
                                        a_st_temp(:,k0,2).' * diag( m_temp(:,2) ) *  V_F * Xtr(1,2) , a_st_temp(:,k0,2).' * diag( m_temp(:,2) ) *  V_F * Xtr(2,2) , a_st_temp(:,k0,2).' * diag( m_temp(:,2) ) *  V_F * Xtr(3,2) , a_st_temp(:,k0,2).' * diag( m_temp(:,2) ) *  V_F * Xtr(4,2) , a_st_temp(:,k0,2).' * diag( m_temp(:,2) ) *  V_F * Xtr(5,2) , a_st_temp(:,k0,2).' * diag( m_temp(:,2) ) *  V_F * Xtr(6,2) 
                                        a_st_temp(:,k0,3).' * diag( m_temp(:,3) ) *  V_F * Xtr(1,3) , a_st_temp(:,k0,3).' * diag( m_temp(:,3) ) *  V_F * Xtr(2,3) , a_st_temp(:,k0,3).' * diag( m_temp(:,3) ) *  V_F * Xtr(3,3) , a_st_temp(:,k0,3).' * diag( m_temp(:,3) ) *  V_F * Xtr(4,3) , a_st_temp(:,k0,3).' * diag( m_temp(:,3) ) *  V_F * Xtr(5,3) , a_st_temp(:,k0,3).' * diag( m_temp(:,3) ) *  V_F * Xtr(6,3) 
                                        a_st_temp(:,k0,4).' * diag( m_temp(:,4) ) *  V_F * Xtr(1,4) , a_st_temp(:,k0,4).' * diag( m_temp(:,4) ) *  V_F * Xtr(2,4) , a_st_temp(:,k0,4).' * diag( m_temp(:,4) ) *  V_F * Xtr(3,4) , a_st_temp(:,k0,4).' * diag( m_temp(:,4) ) *  V_F * Xtr(4,4) , a_st_temp(:,k0,4).' * diag( m_temp(:,4) ) *  V_F * Xtr(5,4) , a_st_temp(:,k0,4).' * diag( m_temp(:,4) ) *  V_F * Xtr(6,4) 
                                        a_st_temp(:,k0,5).' * diag( m_temp(:,5) ) *  V_F * Xtr(1,5) , a_st_temp(:,k0,4).' * diag( m_temp(:,5) ) *  V_F * Xtr(2,5) , a_st_temp(:,k0,5).' * diag( m_temp(:,5) ) *  V_F * Xtr(3,5) , a_st_temp(:,k0,5).' * diag( m_temp(:,5) ) *  V_F * Xtr(4,5) , a_st_temp(:,k0,5).' * diag( m_temp(:,5) ) *  V_F * Xtr(5,5) , a_st_temp(:,k0,5).' * diag( m_temp(:,5) ) *  V_F * Xtr(6,5) 
                                        a_st_temp(:,k0,6).' * diag( m_temp(:,6) ) *  V_F * Xtr(1,6) , a_st_temp(:,k0,4).' * diag( m_temp(:,6) ) *  V_F * Xtr(2,6) , a_st_temp(:,k0,6).' * diag( m_temp(:,6) ) *  V_F * Xtr(3,6) , a_st_temp(:,k0,6).' * diag( m_temp(:,6) ) *  V_F * Xtr(4,6) , a_st_temp(:,k0,6).' * diag( m_temp(:,6) ) *  V_F * Xtr(5,6) , a_st_temp(:,k0,6).' * diag( m_temp(:,6) ) *  V_F * Xtr(6,6) ];



            Gain_Beam(k0,1) = sum( abs( gain_beam_temp(:,:,k0) * ones(B,1) ).^2 ); 
        end


        
toc  

        time1 = time1 + toc;

tic
        m1 = find(s(:,1) == 1); m2 = find(s(:,2) == 1); m3 = find(s(:,3) == 1); m4 = find(s(:,4) == 1); m5 = find(s(:,5) == 1); m6 = find(s(:,6) == 1);

        if s_dic(m1,1,1,1) == 1 &  s_dic(m2,1,2,2) == 1 & s_dic(m3,1,3,3) == 1 & s_dic(m4,1,4,4) == 1 & s_dic(m5,1,5,5) == 1 & s_dic(m6,1,6,6) == 1 & ...
                           s_dic(m1,m2,1,2) == 1 & s_dic(m1,m3,1,3) == 1 & s_dic(m1,m4,1,4) == 1 & s_dic(m1,m5,1,5) == 1 & s_dic(m1,m6,1,6) == 1 & ...
                           s_dic(m2,m1,2,1) == 1 & s_dic(m2,m3,2,3) == 1 & s_dic(m2,m4,2,4) == 1 & s_dic(m2,m5,2,5) == 1 & s_dic(m2,m6,2,6) == 1 & ...
                           s_dic(m3,m1,3,1) == 1 & s_dic(m3,m2,3,2) == 1 & s_dic(m3,m4,3,4) == 1 & s_dic(m3,m5,3,5) == 1 & s_dic(m3,m6,3,6) == 1 & ...
                           s_dic(m4,m1,4,1) == 1 & s_dic(m4,m2,4,2) == 1 & s_dic(m4,m3,4,3) == 1 & s_dic(m4,m5,4,5) == 1 & s_dic(m4,m6,4,6) == 1 & ...
                           s_dic(m5,m1,5,1) == 1 & s_dic(m5,m2,5,2) == 1 & s_dic(m5,m3,5,3) == 1 & s_dic(m5,m4,5,4) == 1 & s_dic(m5,m6,5,6) == 1 & ...
                           s_dic(m6,m1,6,1) == 1 & s_dic(m6,m2,6,2) == 1 & s_dic(m6,m3,6,3) == 1 & s_dic(m6,m4,6,4) == 1 & s_dic(m6,m5,6,5) == 1
            Gain_Beam_Fair_temp1(b,1) = min( Gain_Beam );
        end


    end

    Gain_Beam_Fair_temp2        = max( Gain_Beam_Fair_temp1 );
    
    if Gain_Beam_Fair_temp2 > Gain_Beam_Fair_old
        addr = max( find( Gain_Beam_Fair_temp1 == Gain_Beam_Fair_temp2  ) );
        s(:,addr)  = zeros(B1,1);   s(b1,addr) = 1;
%         mm( : , addr ) = m_temp( : , addr );
        mm = m_temp;
        Gain_Beam_Fair_old = Gain_Beam_Fair_temp2;
        a_st = a_st_temp;
    end

toc

time2 = time2 + toc;

% tic
% 
% 
% 
% 
%     U1 = zeros(B,B); U2 = zeros(B,1); U3 = zeros(B1,B);
%         for i1 = 1:B
%             U2(i1) = s_temp(:,i1).' * U_direc * g(:,i1); 
%             for i2 = 1:B
%                 if i1 ~= i2
%                     U1(i1,i2) = ( s_temp(:,i2) - s_temp(:,i1) ).' * U_direc * g(:,i1);
%                     U3(i1,i2) = s_temp(:,i1).' * D_dis * s_temp(:,i2);
%                 end
%             end
%         end
%         if sum( sum(s,1) <= 1 ) == B && sum( U1 <= 0 , 'all' ) == B^2 && sum(U2>=0)==B && sum(U3>=dmin,'all') == B^2-B
%             Gain_Beam_Fair_temp1(b,1) = min( Gain_Beam );
%         end
%     end
% 
%     Gain_Beam_Fair_temp2        = max( Gain_Beam_Fair_temp1 );
%     Gain_Beam_Fair_old = Gain_Beam_Fair_temp2;
% 
% 
%     %%%%%%%%%%%%%%%%%%%old
%     % 判别是否大于更新后的波束增益是否大于原始波束增益，如果大于，更新s，否则，不进行更新
%     U1 = zeros(B,B); U2 = zeros(B,1); U3 = zeros(B1,B);
%         for i1 = 1:B
%             U2(i1) = s_temp(:,i1).' * U_direc * g(:,i1); 
%             for i2 = 1:B
%                 if i1 ~= i2
%                     U1(i1,i2) = ( s_temp(:,i2) - s_temp(:,i1) ).' * U_direc * g(:,i1);
%                     U3(i1,i2) = s_temp(:,i1).' * D_dis * s_temp(:,i2);
%                 end
%             end
% 
%         end
% 
% toc
% time2 = time2 + toc;
% 
%     if Gain_Beam_Fair_temp2 >= Gain_Beam_Fair_old && sum(sum(s,1) <= 1) == B && sum( U1 <=0 , 'all' ) == B^2 && sum(U2>=0)==B && sum(U3>=dmin,'all') == B^2-B
%         Gain_Beam_Fair_old = Gain_Beam_Fair_temp2;
%         addr = min(find( Gain_Beam_Fair_temp1 == max(Gain_Beam_Fair_temp1) ));
%         s(:,addr)  = zeros(B1,1);   s(b1,addr) = 1;
%         mm(:,b) = mm_temp(:,b);
%     end
                     
end
    Gain_Beam_Fair_ITE(ite_num+1) = Gain_Beam_Fair_old;
end

figure; plot( 1:length(Gain_Beam_Fair_ITE) , Gain_Beam_Fair_ITE , '-o' )


%% 优化全息波束和数字波束

for b = 1:B
    for k = 1:K
        A_ST(k,:,b) = real( V_F.' .* a_st(:,k,b).' + 1 )/2 ;
    end
end
for ite_num = 1:10
% 优化全息波束
cvx_begin
variable coff(K,B)
variable P0(1)
expressions mm(M,B) Gain_Beam(K,1) gain_beam_temp(K,B,K) gain_vec(K,K)

for b = 1:B, mm(:,b) = coff(:,b).' * A_ST(:,:,b); end

for k0 = 1:K
    for b0 = 1:B
        for k1 = 1:K
            gain_beam_temp(k1,b0,k0) = a_st(:,k0,b0).' * diag(V_F * Xtr(b0,k1) ) * mm(:,b0);
        end
    end
end

for k = 1:K
    for k1 = 1:K
        gain_vec(k1,k) = ones(1,B) * gain_beam_temp(k1,:,k)';
    end
end

for k = 1:K
    Gain_Beam(k) = 2 * real( psi(:,k)' * gain_vec(:,k) ) - psi(:,k)' * psi(:,k);
end

maximize P0
subject to
Gain_Beam >= P0;
for b0 = 1:B
    sum( coff(:,b) ) == 1;
end
0<= coff <= 1;
 
cvx_end

for k = 1:K
    psi(:,k) = gain_vec(:,k);
end
% Beam_Gain_Ite(ite_num) = P0;
end

%优化数字波束

for ite_num = 1:10
% 优化全息波束
cvx_begin
variable Xtr(B,K) complex
variable P0(1)
expressions Gain_Beam(K,1) gain_beam_temp(K,B,K) gain_vec(K,K)


for k0 = 1:K
    for b0 = 1:B
        for k1 = 1:K
            gain_beam_temp(k1,b0,k0) = a_st(:,k0,b0).' * diag(V_F * Xtr(b0,k1) ) * mm(:,b0);
        end
    end
end

for k = 1:K
    for k1 = 1:K
        gain_vec(k1,k) = ones(1,B) * gain_beam_temp(k1,:,k)';
    end
end

for k = 1:K
    Gain_Beam(k) = 2 * real( psi(:,k)' * gain_vec(:,k) ) - psi(:,k)' * psi(:,k);
end

maximize P0
subject to
Gain_Beam >= P0;
for b0 = 1:B
   sum( sum( pow_abs( Xtr , 2 ) ) ) <= 1;
end
 
cvx_end

for k = 1:K
    psi(:,k) = gain_vec(:,k);
end
% Beam_Gain_Ite(ite_num) = P0;
end

Beam_Gain_Ite(ITE_NUM) = P0;

end

figure; plot( log(Beam_Gain_Ite) , '-o' )






%% 生成信道
Omega0 = 10^( - ( 32.4 + 17.3 * log10( 5 ) + 20 * log10( fc/1e9 ) ) / 10 );

% 第k个用户的信道增益，包含有Iota个散射链路
Iota = 30;  eta = zeros(K,Iota);
for k = 1:K
    for iota = 1 : Iota
        eta(k,iota) = 1/sqrt(2) * normrnd( 0,1,1,1 ) + 1j/sqrt(2) * normrnd( 0,1,1,1 );
    end
end

% 第k个用户的散射角度，包含有Iota个散射链路
es = zeros(3,K,Iota); theta_scatterer = zeros(K,Iota); phi_scatterer = zeros(K,Iota);
for k = 1:K
    for iota = 1 : Iota
        theta_scatterer(k,iota) = 2 * ( rand(1) - 0.5 ) * 2 * pi; %水平角
        phi_scatterer(k,iota)   = 2 * ( rand(1) - 0.5 ) * 2 * pi; %俯仰角
        es(:,k,iota)              = [ sin( phi_scatterer(k,iota) ) * cos( theta_scatterer(k,iota) ) ; sin( phi_scatterer(k,iota) ) * sin( theta_scatterer(k,iota) ) ; cos( phi_scatterer(k,iota) ) ];
    end
end

% 生成无线信道
H = zeros( B*M , K );
for k = 1:K
    for iota = 0:Iota
        for b = 1:B
            if iota == 0
                if normal_vector_rot{b}.' * e0{k} > 0
                    H( (b-1)*M+1 : b*M , k ) = H( (b-1)*M+1 : b*M , k ) + sqrt( K_rice/(1+K_rice) ) * sqrt(Omega0) * exp( 1j * 2*pi/lambda * ( s(:,b).' * q * e0{k} +  kron( delta_x * ( Px{b}.' * e0{k} ) , ones(My,1) ) + kron( ones(Mx,1) , delta_y * ( Py{b}.' * e0{k} ) )  ) ) ;
                end
            else
                if normal_vector_rot{b}.' * es(:,k,iota) > 0
                    H( (b-1)*M+1 : b*M , k ) = H( (b-1)*M+1 : b*M , k ) + sqrt( 1/(1+K_rice) ) * sqrt(Omega0) * eta(k,iota) * exp( 1j * 2*pi/lambda * ( s(:,b).' * q * es(:,k,iota) +  kron( delta_x * ( Px{b}.' * es(:,k,iota) ) , ones(My,1) ) + kron( ones(Mx,1) , delta_y * ( Py{b}.' * es(:,k,iota) ) )  ) ) ;
                end
            end
        end
    end
end

%% 不优化模拟波束，只优化数字波束
% 生成等效信道
for b = 1:B
    for k = 1:K
        H_eff(b,k) = H( (b-1)*M+1 : b*M , k ).' * diag( mm(:,b) ) * V_F; %等效于有B个射频链路，K个用户的MISO信道
    end
end

psi1 = ones(K,K);

%% 优化数能性能
cvx_begin
variable X(B,K) complex
variable P0(1)
expressions P_temp(K,K) P_EH(K,1) R(K,1)

for k  = 1:K
    for k1 = 1:K
        P_temp(k1,k) = X(:,k1)' * conj( H_eff(:,k) ) ;
    end
end

for k = 1:K
    P_EH(k) = 2 * real( psi1(:,k)' * P_temp(:,k) ) - abs( psi1(:,k)' * psi1(:,k) )^2 ;
end

cvx_end

rho












fprintf('\n');