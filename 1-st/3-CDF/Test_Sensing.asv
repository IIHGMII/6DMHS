clc;clear;



Pt = 40;
Ptx = 10^( (Pt - 30)/10 ); sigma0 = 1e-8; R00 = 1;


format long

% %% ****************************************初始化参数************************************************************************************************************************************************************
for nummmmmm = 1
    % Ptx = 10;
    fc = 30e9;   %载波频率
    c = 3e8;      %光速
    lambda = c/fc;   %波长；
    dx = lambda/4;   %x轴方向天线间隔
    dy = lambda/4;  %y轴方向天线间隔
    Mx = 32; My = 32; M = Mx * My;
    Q  = 1; %每个全息超表面馈源个数
    Dx = Mx * dx;   Dy = My * dy;
    K_rice = 5;
    K = 6; %用户个数
    B = 6; %全息超表面个数，每个全息超表面上配备有M个元素
    NUM_Position = 100; %6DMA空间位置
    delta_x = ( 2 * [0:(Mx-1)].' - Mx + 1 )/2; delta_y = ( 2 * [ 0 : ( My - 1 ) ].' - My + 1 )/2;
    % delta_x = [0:(Mx-1)].';   delta_y = [0:(My-1)].';
    % Coor_Ele_init = [ kron( ones(My,1) , delta_x*dx ) , kron( delta_y*dy , ones(Mx,1) ) , zeros(M,1)  ];  %辐射元素坐标
    Coor_Ele_init = [ kron( delta_x*dx , ones(My,1) ) , kron( ones(Mx,1) , delta_y*dy ) , zeros(M,1)  ];  %辐射元素坐标
    dmin = 0.1;
% figure(1); plot( Coor_Ele_init(:,1) , Coor_Ele_init(:,2) , 'o' )
% % 
%% 引入全息超表面传输模型
Coor_Feed    = [ 0.002984305671304 , 0.001586131606604 , 0 ];   %馈源坐标
% Coor_Feed    = [ 0 , 3.838239570983593e-04 , 0 ];
Dis_Feed2Ele = sqrt( ( Coor_Ele_init - Coor_Feed ).^2 * ones(3,1) );    %馈源到元素的距离
V_F0          = exp( - 1j * 2*pi*sqrt(3)/lambda * Dis_Feed2Ele );    %馈源响应向量
eta0 = 8/3/M;
V_F = sqrt(eta0) * V_F0;

end

tic
parfor ite_num = 1:12




for  num = 1 : 1
%% 6DMA初始空间姿态
% Coor_Ele表示6DMA天线坐标，normal_vector是UPA的法向量
[ Coor_Ele , normal_vector , Rot_Matrix ] = Orientation_Initial(B,Coor_Ele_init,0);
%% 针对初始6DMA位置，生成无线信道
[ h , e0 , theta0, phi0 , theta_scatterer0 , phi_scatterer0 , Iota , eta , Omega ] = Channel_Generation_init( K,B,M,Mx,My,normal_vector,K_rice,Coor_Ele,lambda , Rot_Matrix );
% h{k,b}

end

[ek, error_ben1(:,ite_num)] = Ben_Sensing1(B,M,K,V_F,h,lambda,eta0,delta_x,Mx,Coor_Ele,e0);

end

% sum(sum( error_ben1.^2 )) / numel( error_ben1 )

toc

num = 1;
Fre = [];
for epsilon = 0 : pi/128 : pi
    Fre(num) = numel( find( abs(error_ben1) <= epsilon ) );
    num = num + 1;
end
Fre = Fre / numel( error_ben1 )

figure;plot( 0 : pi/128 : pi , Fre , '--' , 'linewidth' , 2 )

Fre0 = [0	0.533020833333333	0.835104166666667	0.952604166666667	0.987187500000000	0.994166666666667	0.994895833333333	0.995833333333333	0.995937500000000	0.996041666666667	0.996145833333333	0.996458333333333	0.996562500000000	0.996666666666667	0.996979166666667	0.996979166666667	0.997083333333333	0.997187500000000	0.997187500000000	0.997291666666667	0.997395833333333	0.997812500000000	0.998020833333333	0.998020833333333	0.998125000000000	0.998125000000000	0.998125000000000	0.998229166666667	0.998333333333333	0.998333333333333	0.998333333333333	0.998437500000000	0.998437500000000	0.998437500000000	0.998437500000000	0.998437500000000	0.998645833333333	0.998750000000000	0.998750000000000	0.998750000000000	0.998750000000000	0.998750000000000	0.998854166666667	0.998958333333333	0.999062500000000	0.999062500000000	0.999062500000000	0.999062500000000	0.999166666666667	0.999166666666667	0.999166666666667	0.999166666666667	0.999166666666667	0.999166666666667	0.999166666666667	0.999166666666667	0.999166666666667	0.999166666666667	0.999166666666667	0.999166666666667	0.999270833333333	0.999270833333333	0.999270833333333	0.999270833333333	0.999375000000000	0.999479166666667	0.999479166666667	0.999479166666667	0.999791666666667	0.999791666666667	0.999791666666667	0.999791666666667	0.999895833333333	0.999895833333333	0.999895833333333	0.999895833333333	0.999895833333333	0.999895833333333	0.999895833333333	0.999895833333333	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1	1];
hold on;plot( 0 : pi/128 : pi , Fre0 , '-' , 'linewidth' , 2 )
axis([0 pi/2 0 1])
